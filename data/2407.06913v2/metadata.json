{
  "doi": "2407.06913v2",
  "content": [
    {
      "type": "text",
      "text": "Jesse Campbell*\nChunjiang Zhu†\n\nThe all-pairs shortest distances (APSD) with differential privacy (DP) problem takes as input an undirected, weighted graph \\( G = (V, E, w) \\) and outputs a private estimate of the shortest distances in \\( G \\) between all pairs of vertices. In this paper, we present a simple \\( \\tilde{O}(n^{1/3} / \\varepsilon) \\)-accurate algorithm to solve APSD with \\( \\varepsilon \\)-DP, which reduces to \\( \\tilde{O}(n^{1/4} / \\varepsilon) \\) in the \\((\\varepsilon, \\delta)\\)-DP setting, where \\( n = |V| \\). Our algorithm greatly improves upon the error of prior algorithms [CGK+23, FLL22], namely \\( \\tilde{O}(n^{2/3} / \\varepsilon) \\) and \\( \\tilde{O}(\\sqrt{n} / \\varepsilon) \\) in the two respective settings, and is the first to be optimal up to a polylogarithmic factor, based on a lower bound of \\( \\tilde{\\Omega}(n^{1/4}) \\) proven by [BDG+24].\n\nIn the case where a multiplicative approximation is allowed, we give two different constructions of algorithms with reduced additive error. Our first construction allows a multiplicative approximation of \\( O(k \\log \\log n) \\) and has additive error \\( \\tilde{O}(k \\cdot n^{1/k} / \\varepsilon) \\) in the \\( \\varepsilon \\)-DP case and \\( \\tilde{O}(\\sqrt{k} \\cdot n^{1/(2k)} / \\varepsilon) \\) in the \\((\\varepsilon, \\delta)\\)-DP case. Our second construction allows multiplicative approximation \\( 2k - 1 \\) and has the same asymptotic additive error as the first construction. Both constructions significantly improve upon the currently best-known additive error of, \\( \\tilde{O}(k \\cdot n^{1/2+1/(4k+2)}/\\varepsilon) \\) and \\( \\tilde{O}(k \\cdot n^{1/3+2/(9k+3)}/\\varepsilon) \\), respectively from [CGK+23]. Our algorithms are straightforward and work by decomposing a graph into a set of spanning trees, and applying a key observation by [Sea16] that we can privately release APSD in trees with \\( O(\\mathrm{polylog}(n)) \\) error.\n\n*Duke Kunshan University (jesse.campbell@duke.edu)  \n†University of North Carolina at Greensboro (chunjiang.zhu@uncg.edu)\n\n---\n\n**Differential privacy** (DP) is a mathematical framework which quantifies the leakage of sensitive user information by an algorithm. Differential privacy has seen applications in industry and government agencies, with algorithms satisfying differential privacy being adopted by organizations such as Google [ABC+20, BDD+20, BBD+21], Microsoft [DKY17], and the US Census Bureau [GAP18, FMM19]. The definition of differential privacy requires that the probability of a certain outcome being attained from a dataset without the contribution of any single individual is very close to the probability the same outcome is attained from a dataset with the individual's contribution restored, with the notion of *closeness* depending on chosen privacy parameters \\( \\varepsilon \\) and \\( \\delta \\). In the development of differentially private algorithms, a key trade-off occurs between privacy and accuracy, where privacy is, loosely speaking, the amount of leakage, the amount of leakage of sensitive information, and accuracy is how close the private output is to its true value.\n\n---\n\nThe *all-pairs shortest distances* (APSD) problem is a cornerstone of the field of graph algorithms and has been studied extensively. Given a connected graph \\( G = (V, E, w) \\) with \\( n = |V| \\), the goal is to release the shortest distances in \\( G \\) between every vertex pair in \\( V \\times V \\). Algorithms such as the notable Floyd-Warshall algorithm solve APSD in \\( O(n^3) \\) time. It is conjectured that APSD cannot be solved in \\( n^{3-\\Omega(1)} \\) time, being one among a list of problems which are either all solvable in subcubic time, or none of them are [WW10].\n\n---\n\nIn 2016, Adam Sealfon [Sea16] was the first to study the application of differential privacy to the all-pairs shortest distances problem. We follow their DP framework where two graphs are neighboring if they share the same underlying unweighted graphs and their edge weight \\( w \\) differs by at most 1 in the \\( l_1 \\)-distance. This"
    },
    {
      "type": "text",
      "text": "definition is suitable for problems where the graph topology \\(G = (V, E)\\) is public and the edge weights \\(w\\) need to be kept private. For example, the topology of a road map in a navigation system is public knowledge while the weight of an edge depends on the number of vehicles on it, which is typically estimated based on clearly private GPS locations of vehicles. In particular, [Sea16] showed an algorithm based on adding Laplace noise to every edge weight which solves the problem with \\(\\tilde{O}(n/\\epsilon)\\) error (where \\(\\tilde{O}(\\cdot)\\) hides a polylogarithmic term), and posed the question about whether it can be solved with error sublinear in \\(n\\). In addition, they considered special cases and presented \\(\\epsilon\\)-DP algorithms to release APSD on trees with \\(O(\\log^{2.5} (n)/\\epsilon)\\) error, and release APSD on graphs of edge weights bounded by \\(M > 0\\) with error \\(\\tilde{O}((nM)^{2/3}/\\epsilon^{1/3})\\) (\\(\\tilde{O}(\\sqrt{nM/\\epsilon})\\) in the \\((\\epsilon, \\delta)\\)-DP setting). A key observation we make is that the polylogarithmic error in trees is significantly smaller than the polynomial error in general graphs, inspiring the development of the techniques in this work.\n\nLater, Fan et al. [FLL22] and Chen et al. [CGK+23] both positively answered Sealfon's question by proving algorithms for general graphs with error \\(\\tilde{O}(n^{2/3}/\\epsilon)\\) in the \\(\\epsilon\\)-DP case and \\(\\tilde{O}(\\sqrt{n/\\epsilon})\\) in the \\((\\epsilon, \\delta)\\)-DP case. In addition, Chen et al. gave algorithms with improved accuracy for graphs with bounded weights, namely \\(O(n^{0.5616})\\) in the \\(\\epsilon\\)-DP setting and \\(O(n^{0.4143})\\) in the \\((\\epsilon, \\delta)\\)-DP setting. They also presented an algorithm based on the celebrated distance oracle of Thorup and Zwick [TZ05] which reduces the additive error for APSD on general graphs by introducing a multiplicative error term. Moreover, they showed an additive error lower bound of \\(\\Omega(n^{1/6})\\) for the problem on general graphs. This lower bound was recently improved to \\(\\tilde{\\Omega}(n^{1/4})\\) by Bodwin et al. [BDG+24].\n\nIn this paper, we improve upon the accuracy of the currently best-known algorithms for APSD with DP under both additive and mixed additive and multiplicative approximations. In particular, we show the additive approximation problem to be \\(\\tilde{\\Theta}(n^{1/4})\\)-accurate by giving a nearly optimal algorithm which matches the known lower bound of \\(\\tilde{\\Omega}(n^{1/4})\\) up to a polylogarithmic factor.\n\nSection 3 gives algorithms to release estimates of all-pairs distances which incur additive error terms. Table 1 gives a summary of the size of the additive error term for each released distance for known algorithms compared to the improved error in the algorithms in this paper. We greatly improve the additive error from \\(\\tilde{O}(n^{2/3}/\\epsilon)\\) to \\(\\tilde{O}(n^{1/3}/\\epsilon)\\) in the \\(\\epsilon\\)-DP case and from \\(\\tilde{O}(\\sqrt{n/\\epsilon})\\) to \\(\\tilde{O}(n^{1/4}/\\epsilon)\\) in the \\((\\epsilon, \\delta)\\)-DP case. The latter matches the lower bound \\(\\tilde{\\Omega}(n^{1/4})\\) of Bodwin et al. [BDG+24] (up to a polylog factor) for any \\((\\epsilon, \\delta)\\)-DP algorithm. The new upper bounds are even smaller than the previously best results \\(O(n^{0.5616})\\) and \\(O(n^{0.4143})\\) for graphs of bounded weights [CGK+23] while we don't need the assumption on edge weights.\n\nWhen a multiplicative approximation is allowed, it is theoretically possible to break the lower bound of \\(\\tilde{\\Omega}(n^{1/4})\\) for general graphs, however no such algorithm has existed until now. In Section 4, we give two constructions to release APSD with differential privacy that break the lower bound for additive error in general graphs. If an approximation \\(\\tilde{f}(x)\\) of \\(f(x)\\) is \\((\\alpha, \\beta)\\)-accurate, we mean that \\(f(x) - \\beta \\leq \\tilde{f}(x) \\leq \\alpha \\cdot f(x) + \\beta\\). Table 2 gives a summary of the error bounds for known algorithms compared to the improved bounds in the algorithms in this paper. The additive term gets significantly improved compared to previous results."
    },
    {
      "type": "text",
      "text": "Algorithm with Additive Approximation. We give a simple algorithm which releases a private approximation of the shortest path distances between all-pairs of vertices while only incurring an additive approximation. Given a pair of vertices, their private shortest distance is computed in one of two ways depending on the number of edges in a shortest path between them (ties broken arbitrarily). For short paths, or those whose hop lengths are bounded above by some constant $t$, we can directly apply the Laplace mechanism to release their shortest path distance. Namely, we perturb the edge weights in $G$ by adding noise sampled from the Laplace distribution, and compute the shortest path distance on the noisy graph. By a concentration inequality for Laplace random variables (Lemma 2.4), we can achieve additive error $\\tilde{O}(\\sqrt{t}/\\varepsilon)$ for distances computed via this method. Note that previous constructions [Sea16, CGK+23] also add Laplace noise to edge weights, but their analysis simply sums up the error accumulated from each edge in the path, leading to an error $\\tilde{O}(t/\\varepsilon)$.\n\nFor long shortest paths between vertices, we utilize a result from Sealfon [Sea16] to release the distances from the root vertex of a rooted tree to all other vertices with $O(\\mathrm{polylog}(n)/\\varepsilon)$ error. In particular, we construct a hitting set of vertices of size $s$ from which to grow shortest path trees. Then, we privately release the distance between the root vertex in the hitting set and each other vertex in the graph with low error. If at least one of the vertices in the hitting set intersects the shortest path between two vertices, then the shortest path is completely contained within a shortest path tree, and the shortest path distance is the sum of two distances to the root vertex. Moreover, if we assume that the number of edges in the shortest path is bounded below by some constant, there is a high probability that the hitting set will intersect the path. We can divide our privacy budget ($\\varepsilon$) among all of the $s$ shortest path trees, such that by basic composition releasing their distances is $\\varepsilon$-DP, giving an additive error of $\\tilde{O}(s/\\varepsilon)$.\n\nIn theory, letting $s := \\tilde{O}(n/t)$ is an appropriate size to ensure that the hitting set intersects every shortest path that traverses at least $t$ edges with high probability. In the $\\varepsilon$-DP case, we choose $s := \\tilde{O}(n^{1/3})$ to minimize the error from the two methods. The $(\\varepsilon,\\delta)$-DP case is similar, except we use advanced composition to release the distance estimates computed in each shortest path tree, making the error from this method $\\tilde{O}(\\sqrt{s}/\\varepsilon)$, hence the final error is $\\tilde{O}(n^{1/4}/\\varepsilon)$.\n\nAlgorithms with Additive and Multiplicative Approximations. At a high level, our algorithms work by constructing a collection of spanning trees $\\mathbf{T}$, the shortest path distances in which can be used to estimate the shortest path distances in $G$ for every pair of vertices with a multiplicative error. Then, in the same vein as the previous section, we can release APSD for each tree in $\\mathbf{T}$ with additive error $\\tilde{O}(|\\mathbf{T}|/\\varepsilon)$. Releasing APSD in this way yields a combination of multiplicative and additive errors.\n\nIn the first construction, the collection of spanning trees $\\mathbf{T}$ is simply the tree-padding spanner as constructed by Abraham et al. [ACE+20]. In particular, they showed that, for each vertex $v \\in V$, there is a tree $T_v \\in \\mathbf{T}$ such that $d_{T_v}(v, u) \\leq O(k \\log\\log n) \\cdot d_G(v, u)$ for all $u \\in V$, where $k \\in \\mathbb{Z}^+$ is a parameter. The number of trees in $\\mathbf{T}$ is $kn^{1/k}$, hence the total algorithm is $(O(k \\log\\log n), \\tilde{O}(k n^{1/k} / \\varepsilon))$-accurate. The $(\\varepsilon, \\delta)$-DP case is very similar, except we use advanced composition to release the distance estimates computed within each tree, exactly as in the previous section, reducing the additive error to $O(\\sqrt{k n^{1/(2k)}}/\\varepsilon)$.\n\nin [CGK+23], i.e., from $\\tilde{O}(k \\cdot n^{1/2+1/(4k+2)}/\\varepsilon)$ to $\\tilde{O}(k \\cdot n^{1/k}/\\varepsilon)$ in the $\\varepsilon$-DP case and from $\\tilde{O}(k \\cdot n^{1/3+2/(9k+3)}/\\varepsilon)$ to $\\tilde{O}(\\sqrt{k} \\cdot n^{1/(2k)}/\\varepsilon)$ in the $(\\varepsilon,\\delta)$-DP case. While our first result slightly increases the multiplicative error from $2k-1$ to $O(k\\log\\log n)$, its simplicity makes it a good alternative and warm-up for the subsequent construction."
    },
    {
      "type": "text",
      "text": "the formation of **T** in this construction is simple, we include it as a *warm-up* for the next construction, which uses the same mechanism for differentially private release, but requires a more in-depth approach to construct **T**.\n\nOur next construction of **T** is based on the celebrated distance oracle of Thorup and Zwick [TZ05], which allows us to reduce the multiplicative approximation from the previous construction to \\(2k-1\\). The original distance oracle constructs sets of connected vertices called *clusters*, which are computed based on the sets \\(V = A_0 \\supseteq A_1 \\supseteq \\ldots \\supseteq A_{k-1}\\) which decrease in size as the index increases. The original oracle constructs a shortest-path tree which spans the subgraph induced by each cluster, and computes distances estimates based on the distances in these trees. If we were to directly apply Sealfon's result to these cluster-spanning trees, the additive error would be \\(\\tilde{O}(|A_1|/\\varepsilon) = \\tilde{O}(n^{1-1/k}/\\varepsilon)\\), which is higher than the error in our additive approximation.\n\nInstead, we *pack* multiple clusters into a single spanning tree of \\(G\\) such that we can reduce the number of trees in **T**. In the original distance oracle, the total number of edges in the combined spanning trees of the clusters is \\(O(kn^{1+1/k})\\), so ideally we should be able to fit all of the clusters into \\(n^{1/k}\\) trees at each level \\(1 \\leq i \\leq k-1\\), resulting in a final additive error of \\(\\tilde{O}(kn^{1/k}/\\varepsilon)\\). The main obstacle is that, in the original distance oracle, the clusters are not necessarily disjoint, and consequently adding the edges from their spanning trees to a single graph may contain cycles. To overcome this, we divide each set \\(A_i\\) into \\(\\tilde{O}(n^{1/k})\\) (not necessarily disjoint) sets \\(A_i^r\\) and modify the definition of clusters by ensuring that any vertex in a cluster centered at \\(w \\in A_i^r\\) is closer to \\(w\\) than any other center in \\(A_i^r\\). In this way, the clusters with centers in \\(A_i^r\\) are guaranteed to be disjoint. Hence, we can add all the edges from the trees spanning each subgraph induced by a cluster with center in \\(A_i^r\\) into exactly one spanning tree of \\(G\\). Consequently, \\(|\\mathbf{T}| = \\tilde{O}(kn^{1/k})\\) as desired.\n\nFor the analysis, we show that our sets \\(A_{i+1}\\) are large enough relative to the size of \\(A_i^r\\) such that every vertex is closer to \\(A_{i+1}\\) than \\(A_i^r\\) with high probability. Going back to the original distance oracle, this implies that our modified clusters are at least as large as the original clusters, and hence any distance we can compute from a shortest path tree spanning the original cluster we can also compute from a shortest path tree spanning our modified cluster. This observation implies that the original stretch analysis from [TZ05] also applies in our setting. In particular, this gives a multiplicative approximation of \\(2k-1\\). Hence, our total algorithm is \\((2k-1, \\tilde{O}(kn^{1/k}))\\)-accurate in the \\(\\varepsilon\\)-DP case and \\((2k-1, O(\\sqrt{kn^{1/(2k)}}))\\)-accurate in the \\((\\varepsilon, \\delta)\\)-DP case.\n\n## 1.4 Related Work\n\nIn 2009, Hay et al. [HLMJ09] were the first to study differentially private graph algorithms by giving a mechanism to release a private estimate of the degree distribution in a graph. In their work, they introduce the notions of node- and edge-differential privacy, which defines neighboring graphs based on their underlying graph topology. Algorithms with node- and edge-differential privacy have been studied considerably in recent literature [LLXL21, JWC23, LML20, ZNF23, SU21, HCYH24, ELRS23].\n\nBy contrast, Sealfon [Sea16] introduced the all-pairs shortest distances problem with differential privacy, defining neighboring graphs based on differing edge weights assigned to a fixed, public graph topology. In particular, Sealfon constructed an \\(\\varepsilon\\)-DP algorithm that releases APSD in trees with additive error \\(O(\\log^{2.5}(n) \\cdot \\log(1/\\gamma)/\\varepsilon)\\) with probability \\(1-\\gamma\\), which is the basis of our algorithms in this paper. Furthermore, for graphs with edge weights bounded by \\(M>0\\), they proved an upper bound of \\(O((n \\cdot M)^{2/3} \\cdot \\log(n \\cdot M \\cdot \\varepsilon/\\gamma) / \\varepsilon^{1/3})\\) in the pure-DP case and \\(O(\\sqrt{n} \\cdot M \\cdot \\log(1/\\delta)/\\varepsilon \\cdot \\log(n \\cdot M \\cdot \\varepsilon/\\gamma))\\) in the approximate-DP case. For general graphs, Sealfon used a simple application of the Laplace mechanism to achieve additive error \\(\\tilde{O}(n)\\) in the \\(\\varepsilon\\)-DP case, but posed the question about whether an algorithm for general graphs with error sublinear in \\(n\\) is possible.\n\nLater, Chen et al. [CGK\\(^+\\)23] positively answered Sealfon's question by giving algorithms to release all-pairs shortest distances with error \\(O(n^{2/3}\\cdot\\log^{4/3}(n)/\\varepsilon)\\) in the pure-DP case and \\(O(\\sqrt{n}\\cdot\\log(n)\\cdot\\sqrt{\\log(1/\\delta)/\\varepsilon})\\) in the approximate-DP case. Moreover, for graphs with bounded edge weights, they gave an algorithm which is \\(O(n^{(\\sqrt{17}-3)/2+o(1)}/\\varepsilon)\\)-accurate in the \\(\\varepsilon\\)-DP case and \\(O(n^{\\sqrt{2}-1+o(1)}/\\varepsilon)\\)-accurate in the \\((\\varepsilon, \\delta)\\)-DP case. In the case where multiplicative error is allowed, Chen et al. gave an \\((2k-1, O(k\\cdot n^{(k+1)/(2k+1)}\\cdot\\log^2(n)/\\varepsilon))\\)-accurate"
    },
    {
      "type": "text",
      "text": "algorithm for APSD with ε-DP and a (2k − 1, O(n^((k+1)/(3k+1)) · log (n)^((5k+2)/(3k+1)) · log (1/δ)^(k/(3k+1))/ε))-accurate algorithm for APSD with (ε, δ)-DP. Similar to our work, their algorithm is based on the oracle of Thorup and Zwick [TZ05], which they adapted to the DP setting by using the exponential mechanism to select bunches of vertices based on their distance to a fixed vertex.\n\nOther notable results are those of Fan et al. [FLL22], who gave an alternative algorithm to Chen et al. for solving APSD with DP with error sublinear in n. Furthermore, Fan and Li [FL22] gave improved algorithms for trees with bounded depth and grid-graphs. Ebrahimi et al. gave improved error bounds for graphs with bounded tree-width [EMK23]. Moreover, related graph problems such as shortest paths publishing and range query on shortest paths with differential privacy have seen a recent increase in the literature [CSC+24, DGUW23].\n\nAnother contribution of Chen et al. was proving a lower bound for the additive error of Ω(n^(1/6)) in any algorithm on general graphs, for a sufficiently small ε, δ > 0, by exploiting a reduction from the linear queries problem to APSD, and a hereditary discrepancy lower bound provided by Chazelle and Lvov [CL01]. Chen et al. noted that the greatest lower bound achievable by this method is Ω(n^(1/4)). On this note, Bodwin et al. [BDG+24] proved a lower bound of Ω(n^(1/4)/√log n) as a result of a better discrepancy lower bound.\n\nGiven a mechanism that takes as input a dataset and releases some aggregate statistical information about the dataset, the goal of differential privacy is to protect any one individual’s privacy whose data is included in the dataset. For this reason, it is necessary to define the notion of what it means for a dataset to differ in the contribution of one individual. In our case, G = (V, E, w) and G' = (V, E, w̃) are neighbors if their weight vectors differ in the l₁ norm by at most 1.\n\n**Definition 2.1.** Two graphs G = (V, E, w) and G' = (V, E, w̃) with equivalent topology are said to be neighboring if ||w − w̃||₁ ≤ 1.\n\nGiven a notion of neighboring datasets X and X', we can define the notion of the sensitivity of a function that takes a dataset as input as the most the function can differ over neighboring datasets.\n\n**Definition 2.2.** The l₁ sensitivity of f : X → R^D is defined as Δ₁(f) := max_{X, X'} ||f(X) − f(X')||₁, where X, X' are neighboring datasets.\n\nWe now present the formal definition of differential privacy. Intuitively, a differentially private system limits the amount of information we can gain about any individual in a dataset based solely on the outcome of a mechanism which takes the dataset as input. The strictness of this limitation is controlled by privacy parameters ε, δ ≥ 0.\n\n**Definition 2.3.** An algorithm M : X → R^D is said to be (ε, δ)-differentially private if, for all outcomes S ⊆ R^D and neighboring datasets X, X',\n\nP[M(X) ∈ S] ≤ e^{ε} · P[M(X') ∈ S] + δ\n\nWe call the case where δ = 0 pure differential privacy and the case where δ > 0 approximate differential privacy.\n\nOne of the strongest aspects of differentially private mechanisms are their composition properties. Namely, the aggregation of outputs from multiple differentially private mechanisms is itself differentially private, albeit with gradually degrading privacy parameters. We present here two main results about the composition of differentially private systems which we will use several times throughout this paper.\n\n**Lemma 2.1** (Basic Composition, [DMNS06, DL09]). Let ε, δ ∈ [0, 1] and k ∈ N. If we run k mechanisms where each mechanism is (ε/k, δ/k)-differentially private, then the entire algorithm is (ε, δ)-differentially private."
    },
    {
      "type": "text",
      "text": "Lemma 2.2 (Advanced Composition, [DMNS06, DR14]). Let ε, δ ∈ (0, 1] and k ∈ ℕ. If we run k mechanisms where each mechanism is (ε/(2√(2k log (2/δ))), δ/2k)-DP, then the entire algorithm is (ε, δ)-DP.\n\nRegarding Lemma 2.2, we note that running k mechanisms where each mechanism is ε/(2√(2k log (2/δ)))-DP is at least (ε, δ)-DP, as each individual mechanism we run has an even stronger privacy guarantee.\n\nNext, we present the Laplace mechanism, which is one of the primary tools in the theory of differential privacy. In specific, the Laplace mechanism describes how much one needs to perturb a released statistic in order to guarantee it is ε-DP.\n\nLemma 2.3 ([DMNS06]). Given any function f : X → ℝ^k, the Laplace mechanism on input X ∈ X independently samples Y₁, ..., Y_k according to Lap(Δ₁(f)/ε) and outputs,\nM_{f,ε}(X) = f(X) + (Y₁, ..., Y_k)\nThe Laplace mechanism is ε-differentially private.\n\nWe also present a result about the concentration of Laplace random variables.\n\nLemma 2.4 ([CSS11]). Let X₁, ..., X_t be independent random variables distributed according to Lap(b), and let X = X₁ + ... + X_t. Then for all γ ∈ (0, 1), with probability at least 1 − γ we have,\n|X| < O(b√t log (1/γ))\n\nNext, we state a Chernoff inequality which bounds the tail probability of a binomial random variable.\n\nLemma 2.5 ([CL06]). Let X ∼ Binomial(n, p) be a random variable, then,\nP[X ≤ E[X] − λ] ≤ e^{-λ²/2E[X]}\n\n## 3 A Nearly-Optimal Algorithm for General Graphs\n\nIn this section, we present a differentially private algorithm for APSD on general graphs which is Õ(n^{1/3}/ε)-accurate in the ε-DP case and Õ(n^{1/4}/ε)-accurate in the (ε, δ)-DP case. Our algorithm is based on a key observation that we can release shortest path distances in trees with polylog(n) error.\n\nWe denote by d_G(u, v) the shortest distance between u, v ∈ V in the graph G. When it is clear in which graph we are computing the distance, G is not specified. Furthermore, we denote by h(u, v) the hop length between u and v, namely, h(u, v) = d_{G'}(u, v) where G' = (V, E, {1}^{|E|}). We let d_G^{(t)}(u, v) be the shortest t-hop path between u and v in the graph G, or the shortest path between u and v under the constraint of traversing at most t edges. In particular, if h(u, v) > t, then d_G^{(t)}(u, v) = ∞.\n\nThis section is structured as follows: we will first prove a result which bounds the error of releasing distances via the Laplace mechanism for paths with bounded hop length. Then, we will present the result by Sealfon which gives an accurate algorithm for computing shortest path distances on rooted trees. Finally, we will show how to combine these two mechanisms to release APSD with the claimed error bounds.\n\nThe input perturbation algorithm takes as input a graph G, adds noise to each edge weight according to Lap(1/ε), and releases the shortest distances computed on the noisy graph. It is a simple application of the Laplace mechanism (Lemma 2.3) to the function f : w → ℝ^{n²} which takes as input the edge weights of a graph and outputs all-pairs shortest distances. The result was proven by [Sea16] and later by [CGK⁺23]. By a more careful analysis, we establish a lower error for this method.\n\nLemma 3.1. Let t ∈ ℕ, ε ∈ (0, 1], and γ ∈ (0, 0.5]. There is an ε-DP algorithm for computing d̃^{(t)}(u, v) for every u, v ∈ V such that with probability 1 − γ we have,\nmax_{u,v ∈ V} |d̃^{(t)}(u, v) - d_G^{(t)}(u, v)| ≤ O(√t · log(n/γ)/ε)"
    },
    {
      "type": "text",
      "text": "Since a shortest path cannot traverse any single edge more than once, the ℓ₁ sensitivity of a function that takes as input w and returns the shortest path distance between a pair of vertices is 1. Consequently, by Lemma 2.3, releasing the graph G̃ is ε-differentially private. Since the shortest t-hop distances are simply a post-processing of the edge weights of G̃, we can also release them with ε-differential privacy.\n\nProof. The algorithm works as follows: given a weighted, undirected graph, G = (V, E, w), we construct a noisy graph G̃ = (V, E, w̃) by adding Laplace noise to each component of w, independently sampled from Lap(1/ε). Then, we return d̃^(t)(u, v) ← d̃_{G̃}^{(t)}(u, v) for each u, v ∈ V.\n\nTo achieve our upper bound for the accuracy, we note that each distance d̃_{G̃}^{(t)}(u, v) is the sum of a maximum of t edge weights, hence the total error in the estimate d̃^{(t)}(u, v) is the accumulation of at most t Laplace random variables. By Lemma 2.4, with probability at least 1 − γ / n² we have,\n\n|d̃^{(t)}(u, v) − d_{G̃}^{(t)}(u, v)| ≤ O(√t · log(n²/γ)/ε) = O(√t · log(n/γ)/ε)\n\nby Proposition E.2. By a union bound, with probability at least 1 − γ, this upper bound holds for each of the n² released distances.\n\nNext, we will present a result from [Sea16] which gives a recursive algorithm for computing the shortest path distances between the root and all other vertices in a rooted tree, such that the maximum error in any single released distance is O(polylog(n)). We state the result here but defer its proof to Appendix A.\n\nLemma 3.2 (Theorem 4.1 in [Sea16]). Let T_z = (V, E, w) be a tree with root vertex z ∈ V, ε ∈ (0, 1], and γ ∈ (0, 0.5]. Then there is an ε-DP algorithm for releasing the distance between z and every u ∈ V that is O(log^{1.5}(n) · log(n/γ)/ε)-accurate with probability 1 − γ.\n\nNext, we show how to combine Lemma 3.1 and Lemma 3.2 to release all-pairs distances with a nearly-optimal additive error. Our proof borrows some ideas from the proof of Lemma 3.1 in [CGK⁺23].\n\nTheorem 3.1. For γ ∈ (0, 0.5] and ε ∈ (0, 1], there is an ε-DP algorithm for computing all-pairs shortest distances that is O(n^{1/3} · log(n)^{11/6} · log(1/γ)/ε)-accurate with probability 1 − γ − 1/n²."
    },
    {
      "type": "text",
      "text": "**Corrected text from the OCR output (in original order):**\n\nto release the shortest path distances between $z$ and $u \\in V$, denoted by $\\tilde{d}(z, u)$. Furthermore, we use the $\\varepsilon/2$-DP input perturbation algorithm (Lemma 3.1) to compute the shortest $t$-hop distances in $G$ for every pair of vertices $u, v \\in V$, where $t := \\lceil 10 \\cdot (n/s) \\log(n) \\rceil$, denoted by $d_G^{(t)}(u, v)$. Then, we let,\n$$\nd(u,v) = \\min \\left\\{ d_G^{(t)}(u,v), \\min_{z \\in S} \\left\\{ \\tilde{d}(z,u) + \\tilde{d}(z,v) \\right\\} \\right\\}\n$$\nbe the final distance approximation. By basic composition (Lemma 2.1), running the $s$, $\\varepsilon/(2s)$-DP mechanisms and the single $\\varepsilon/2$-DP mechanism is $\\varepsilon$-DP. In particular, we note that we do not release any shortest path trees themselves, hence no shortest path information is revealed. For the accuracy analysis, we will first show that for pair of vertices $(u,v) \\in V \\times V$, either,\n\n- **Case A.** There is a vertex $z \\in S$ that intersects the shortest path in $G$ from $u$ to $v$, or,\n\n- **Case B.** The shortest path between $u$ and $v$ in $G$ is the $t$-hop shortest path between $u$ and $v$.\n\nIn particular, assume that $(u,v)$ is not in **Case B**. Let $u = p_1, p_2, ..., p_l = v$ be a shortest path between $u$ and $v$ in $G$, with ties broken arbitrarily. Because the vertices in $S$ are sampled uniformly, each vertex in $V$ has probability $s/n$ of being included in $S$. Consequently, the probability that none of the vertices $p_j$ for $j \\in [l]$ are included in $S$ is $(1-s/n)^l \\le (1-s/n)^t \\le 1/n^4$ by **Proposition E.1**. It follows that with probability $1-1/n^4$, $(u,v)$ is in **Case A**. We condition on this holding true for all $n^2$ pairs of vertices with probability at least $1-1/n^2$, by a union bound. $(*)$\n\nWe begin our accuracy analysis with **Case A**. Suppose $p_i \\in S$ for some $i \\in [l]$, then $d_G(u,v) = d_{T_{p_i}}(u, p_i) + d_{T_{p_i}}(p_i, v)$. We note that these distances are estimated in **Line 11**. Moreover, **Lemma 3.2** ensures that, with probability $1 - \\gamma/(2s)$,\n$$\n|d_G(u,v) - (\\tilde{d}(u,p_i) + \\tilde{d}(p_i,v))| \\leq O(s \\cdot \\log^{1.5}(n) \\cdot \\log(2sn/\\gamma)/\\varepsilon). \\tag{1}\n$$\nWe condition on this upper bound for all $s$ trees with probability at least $1 - \\gamma/2$, by a union bound.\n\nWe move on to the analysis of **Case B**. Since we are assuming that the true shortest path between $u$ and $v$ has at most $t$ edges, **Lemma 3.1** ensures that with probability $1 - \\gamma/2$,\n$$\n|d(u,v) - d_G^{(t)}(u,v)| \\leq O(\\sqrt{n/s} \\cdot \\log^{1.5}(n) \\cdot \\log(1/\\gamma)/\\varepsilon) \\tag{2}\n$$\nby **Proposition E.2** to simplify the argument of a logarithmic term. By a union bound, the event $(*)$ and the upper bounds (1) and (2) hold with probability $1 - \\gamma - 1/n^2$. Furthermore, choosing $s = n^{1/3}/\\log^{2/3}(n)$ by balancing the two errors, the upper bounds (1) and (2) ensure,\n$$\n\\max_{u, v \\in V} |d_G(u,v) - d(u,v)| \\leq O\\left(n^{1/3} \\cdot \\log^{5/6}(n) \\cdot \\log\\big(2n^{4/3}/(\\gamma \\cdot \\log^{2/3}(n))\\big)/\\varepsilon\\right)\n$$\n$$\n= O\\left(n^{1/3} \\cdot \\log^{11/6}(n) \\cdot \\log(1/\\gamma)/\\varepsilon\\right)\n$$\nby **Proposition E.2**.\n\nNext, we present a similar result in the $(\\varepsilon, \\delta)$-DP setting, which is optimal up to a polylogarithmic factor. The proof is analogous and thus deferred to **Appendix B**.\n\n**Theorem 3.2.** *For $\\gamma \\in (0,0.5]$ and $\\varepsilon, \\delta \\in (0,1]$, there is an $(\\varepsilon, \\delta)$-DP algorithm for computing all-pairs shortest distances that is $O(n^{1/4} \\cdot \\log^2(n) \\cdot \\sqrt{\\log(2/\\delta)} \\cdot \\log(1/\\gamma)/\\varepsilon)$-accurate with probability $1 - \\gamma - 1/n^2$.*\n\n## 4 Improved Algorithms Allowing Multiplicative Error\n\nChen et al. [CGK$^+$23] noted that the known lower bound of $\\widetilde{\\Omega}(n^{1/4})$ for the purely additive error of an algorithm that privately releases all-pairs distances does not apply in the setting where a multiplicative approximation is allowed. In this section, we adapt two existing mechanisms which output shortest distance estimates to the DP setting, which are the first of their kind to have additive error below the lower bound $\\widetilde{\\Omega}(n^{1/4})$ in the purely additive setting, as the current best additive term [CGK$^+$23] is $\\widetilde{O}(k \\cdot n^{1/3 + 2/(9k+3)}/\\varepsilon)$. In specific, both of our methods decompose a graph into a collection $\\mathcal{T}$ of spanning trees such that for"
    },
    {
      "type": "text",
      "text": "any pair of vertices \\( u, v \\in V \\), there is a tree \\( \\mathcal{T} \\in \\mathbf{T} \\) that satisfies \\( d_{\\mathcal{T}}(u, v) \\leq \\alpha \\cdot d_G(u, v) \\) where \\( \\alpha \\) is the multiplicative stretch factor. We then turn to an algorithm of privately releasing all-pairs distances in trees with polylogarithmic additive error. Hence, this leads to a mixed multiplicative and additive error in the shortest distance estimates.\n\nThe motivation for decomposing a graph into trees comes from a corollary of Theorem 3.2 originally proven by [Sea16] which extends the algorithm for releasing distances between the root of a tree and every other vertex to all-pairs distances in a tree. We state the result here and defer the proof to Appendix A.\n\n**Corollary 4.1 (Theorem 4.2 in [Sea16]).** Let \\( \\mathcal{T} = (V, E, w) \\) be a tree with \\( \\epsilon \\in (0, 1] \\) and \\( \\gamma \\in (0, 0.5] \\). Then there is an \\( \\epsilon \\)-DP algorithm for releasing all-pairs distances on \\( \\mathcal{T} \\) that is \\( O(\\log^{1.5}(n) \\cdot \\log(n/\\gamma)/\\epsilon) \\)-accurate with probability \\( 1 - \\gamma \\).\n\nIn what follows we will give two different constructions of algorithms to release all-pairs shortest distances in general graphs with a multiplicative error term, making heavy use of Corollary 4.1. Construction 1 can be considered a warm-up for Construction 2, as the result from Construction 2 is stronger, but requires a more in-depth analysis.\n\n## 4.1 Construction 1: Tree-Padding Spanner\n\nIn this section, we give a simple construction of an algorithm with multiplicative error \\( O(k \\log \\log n) \\) which releases all-pairs distances with differential privacy. This section also serves as a warm-up for the next construction.\n\nAbraham et al. [ACE+20] gave the first construction of a *tree-padding spanner*, which, given a graph \\( G = (V, E, w) \\), returns a collection of spanning trees \\( \\mathbf{T} \\) such that for each vertex \\( v \\in V \\), there exists a tree \\( \\mathcal{T} \\in \\mathbf{T} \\) that is a sourcewise \\( O(k \\log \\log n) \\)-spanner for the source set \\( \\{v\\} \\), or equivalently, \\( d_{\\mathcal{T}}(v, u) \\leq O(k \\log \\log n) \\cdot d_G(v, u) \\) for all \\( u \\in V \\). We state the result here, but refer the interested reader to [ACE+20] for a detailed proof.\n\n**Lemma 4.1 (Theorem 2 in [ACE+20]).** For a parameter \\( k \\in \\mathbb{Z}^+ \\), there exists an algorithm that finds a collection \\( \\mathbf{T} \\) of \\( k \\cdot n^{1/k} \\) spanning trees of \\( G \\) such that for every \\( u, v \\in V \\), there exists a tree \\( \\mathcal{T} \\in \\mathbf{T} \\) such that \\( d_{\\mathcal{T}}(u, v) \\leq O(k \\log \\log n) \\cdot d_G(u, v) \\).\n\nBy applying Corollary 4.1 to each tree in \\(\\mathbf{T}\\), we can release all-pairs distances in the tree-padding spanner, and use these distances to compute an estimate for each pair of vertices in \\( V \\).\n\n**Theorem 4.1.** For \\( \\gamma \\in (0, 0.5] \\), \\( k \\in \\mathbb{Z}^+ \\), and \\( \\epsilon \\in (0, 1] \\), there is an \\( \\epsilon \\)-DP algorithm to release all-pairs shortest distances that is \\( (O(k \\log \\log n), O(k \\cdot n^{1/k} \\cdot \\log^{2.5}(n) \\cdot \\log(k) \\cdot \\log(1/\\gamma)/\\epsilon)) \\)-accurate with probability \\( 1 - \\gamma \\).\n\n**Proof.** Let \\( \\mathbf{T} \\) be the tree-padding spanner constructed in Lemma 4.1. For each \\( \\mathcal{T} \\in \\mathbf{T} \\) and \\( u, v \\in V \\), we run the \\( \\epsilon/(k n^{1/k}) \\)-DP algorithm given by Corollary 4.1 to release a private estimate of the distance \\( d_{\\mathcal{T}}(u, v) \\), denoted by \\( \\tilde{d}_{\\mathcal{T}}(u, v) \\). By basic composition (Lemma 2.1), releasing all the distances is \\( \\epsilon \\)-DP. Moreover, for each estimate \\( \\tilde{d}_{\\mathcal{T}}(u, v) \\), the result of Corollary 4.1 ensures, with probability \\( 1 - \\gamma \\) by a union bound over all \\( k n^{1/k} \\) trees,\n\\[\n\\max_{u,v \\in V} |d_{\\mathcal{T}}(u, v) - \\tilde{d}_{\\mathcal{T}}(u, v)| \\leq O\\left(k \\cdot n^{1/k} \\cdot \\log^{1.5}(n) \\cdot \\log\\left(\\frac{n}{\\gamma/k n^{1/k}}\\right)/\\epsilon\\right)\n\\]\n\\[\n= O\\left(k \\cdot n^{1/k} \\cdot \\log^{2.5}(n) \\cdot \\log(k) \\cdot \\log(1/\\gamma)/\\epsilon\\right)\n\\]\nwhere the equality follows from Proposition E.2. For each \\( u, v \\in V \\), by letting \\( \\tilde{d}(u, v) \\leftarrow \\min_{\\mathcal{T} \\in \\mathbf{T}} \\tilde{d}_{\\mathcal{T}}(u, v) \\), the result of Lemma 4.1 guarantees that the stretch of the estimate is at most \\( O(k \\log \\log n) \\). Hence, the total algorithm is \\( (O(k \\log \\log n), O(k \\cdot n^{1/k} \\cdot \\log^{2.5}(n) \\cdot \\log(k) \\cdot \\log(1/\\gamma)/\\epsilon)) \\)-accurate.\n\nWe also provide a similar (\\( \\epsilon, \\delta \\))-DP algorithm, and defer the proof to Appendix C.\n\n**Theorem 4.2.** For any \\( \\gamma \\in (0, 0.5] \\), \\( k \\in \\mathbb{Z}^+ \\) and \\( \\epsilon, \\delta \\in (0, 1] \\), there is an (\\( \\epsilon, \\delta \\))-DP algorithm to release all-pairs shortest distances that is \\( (O(k \\log \\log n), O(\\sqrt{k} \\cdot n^{1/(2k)} \\cdot \\log^{2.5}(n) \\cdot \\log(k) \\cdot \\sqrt{\\log(2/\\delta)} \\cdot \\log(1/\\gamma)/\\epsilon)) \\)-accurate with probability \\( 1 - \\gamma \\)."
    },
    {
      "type": "text",
      "text": "In this section, we give an algorithm that modifies the oracle of Thorup and Zwick [TZ05] in order to apply **Corollary 4.1** effectively. The original oracle constructs a total of O(n^{1-1/k}) sets of vertices called *clusters*, and for each cluster computes a shortest path tree spanning it. The shortest path distances within each cluster are then used to output the distance approximations. Applying **Corollary 4.1** directly to all O(n^{1-1/k}) trees would result in \\~O(n^{1-1/k}/ε) additive error, which is clearly worse than our result from the previous section. Instead, we modify the sampling process to *pack* multiple clusters into a single spanning tree of G. Namely, we add the edges from the shortest path tree spanning each cluster to a single graph to form a spanning tree of G. This allows us to bound the number of times we need to call the algorithm from **Corollary 4.1** to be \\~O(k · n^{1/k}). In the original distance oracle, this is not possible as the clusters can share common vertices with one another, so adding their shortest path spanning trees to a single graph may create cycles.\n\nThroughout this section, for a subset of vertices S ⊆ V and v ∈ V, we let d(v, S) = min_{u∈S} d(v, u). Furthermore, for an integer parameter i ∈ Z^+, we let [i] := {1, 2, ..., i}. Lastly, for a graph H = (V_H, E_H), we let E(H) = E_H.\n\nOur algorithm (**Algorithm 2**) begins by constructing the sets V = A_0 ⊇ A_1 ⊇ ... ⊇ A_{k-1}, but starting from A_{k-1} to A_1 in a backward manner. In particular, the algorithm runs for t := ⌈100 · n^{1/k} log(n)⌉ iterations, and we sample a portion of the vertices in each set A_i in each iteration. For each r ∈ [t], we begin by letting A^r_{k-1} be a single vertex sampled at random from V. Then, for each i ∈ [k - 2], we let A^r_i be A^r_{i+1}, and sample n^{1-(i+1)/k} - n^{1-(i+2)/k} vertices randomly from the set V - A^r_{i+1} to add to the set A^r_i. Lastly, we let A_i = ∪_r A^r_i for each i ∈ [k - 1].\n\nMoreover, for every w ∈ A^r_i, we let C^r(w) = {u ∈ V | d(w, u) < d(u, A^r_i - {w})} be the cluster *centered at* w. We define clusters in this way in order to ensure that the vertices in each cluster with a center in A^r_i are disjoint, so that we can *fit* them into a single spanning tree.\n\nThe next step is to define the *pivots* and *bunches* for every vertex u ∈ V, which we do in the same way as [TZ05], except for our modified sets A_i. Namely, for each i ∈ [k - 1], we let p_i(u) ∈ A_i be a vertex such that d_G(u, p_i(u)) = d_G(u, A_i), where ties are broken arbitrarily. In particular, if d(u, A_i) = d(u, A_{i+1}), then p_i(u) ← p_{i+1}(u). Furthermore, we define the bunches as B(u) = {w ∈ V | d(w, u) < d(u, p_{i+1}(u))}.\n\nWe make the following observations about our construction which will be critical to our later analysis. Throughout our analysis, we assume that 2 ≤ k ≤ ⌊log(n)/log(2)⌋ such that n^{1/k} ≥ 2 for simplicity. At the end of this section, we will justify this assumption.\n\nOur first observation establishes that each cluster is disjoint by construction.\n\n**Lemma 4.2.** *For all r ∈ [t], i ∈ [k-1], and w_1, w_2 ∈ A^r_i with w_1 ≠ w_2, C^r(w_1) ∩ C^r(w_2) = ∅.*\n\nProof. By way of contradiction, suppose C^r(w_1) ∩ C^r(w_2) ≠ ∅. Then, there exists a vertex u ∈ C^r(w_1) ∩ C^r(w_2). Let a_1 be the closest vertex to u in A^r_i - {w_1} and a_2 be the closest vertex to u in A^r_i - {w_2}. Then, by our definition of clusters,\n\nd(w_1, u) < d(u, a_1) ≤ d(u, w_2) < d(u, a_2) ≤ d(u, w_1)\n\nHence no such vertex u can exist.\n\nNext, we make a key observation that no one vertex has a higher probability of being included in the sets A^r_i or A_i than any other vertex.\n\n**Lemma 4.3.** *Each vertex u ∈ V has a uniform probability of being included in A^r_i and A_i for i ∈ [k - 1] and r ∈ [t].*\n\nProof. By Line 15, the set A_i is simply the union of the sets A^r_i over all values of r ∈ [t]. Since the sampling procedure in each of the t iterations is independent with respect to every other iteration, if each vertex has an equal probability of being included in A^r_i, then each vertex has an equal probability of being included in A_i."
    },
    {
      "type": "text",
      "text": "Therefore, it suffices to show that $\\mathbb{P}[u \\in A^{r}_{i}] = |A^{r}_{i}|/n = n^{-(i+1)/k}$. We prove the claim by induction on $i$. For the base case of $i = k-1$, by Line 3, $A^{r}_{k-1}$ consists of a single vertex picked at random, so each vertex has probability $1/n$ of being picked. Now, suppose that $1 \\leq i < k-1$ and the claim holds for index $i + 1$. By Lines 5 and 7, $\\mathbb{P}[u \\in A^{r}_{i}] = \\mathbb{P}[u \\in A^{r}_{i+1}] + \\mathbb{P}[u \\notin A^{r}_{i+1}] \\cdot \\mathbb{P}[u \\in A^{r}_{i} - A^{r}_{i+1}]$. By the induction hypothesis, $\\mathbb{P}[u \\in A^{r}_{i+1}] = n^{-(i+2)/k}$, hence,\n\\[\n\\mathbb{P}[u \\in A^{r}_{i}] = n^{-(i+2)/k} + (1-n^{-(i+2)/k}) \\cdot \\frac{n^{1-(i+1)/k} - n^{1-(i+2)/k}}{n - n^{1-(i+2)/k}} = n^{-(i+1)/k}\n\\]\n\nIn our sampling procedure, the sets $A^{r}_{i}$ are sampled without replacement, however, a single vertex can be sampled at the $i$th level in more than one iteration $r \\in [t]$. Consequently, $|A_{i}| \\leq t \\cdot |A^{r}_{i}|$, so for our analysis we must give a lower bound on the size of $A_{i}$, which we do next.\n\nProof. By Line 15, for $i \\in [k-1]$, $A_{i}$ is the union of the sets $A^{r}_{i}$ over $r \\in [t]$, each of which is sampled uniformly and independently from $V$ without replacement by Lemma 4.3 and has size $n^{1-(i+1)/k}$. In particular, if we fix $u \\in V$, then $\\mathbb{P}[u \\in A^{r}_{i}] = |A^{r}_{i}|/n$. Hence, the probability that $u$ is included in $A_{i}$ after $t$ iterations is $1 - (1 - |A^{r}_{i}|/n)^{t} = p_{i}$. Let $X_{i} \\sim \\text{Binomial}(n, p_{i})$ be the number of vertices in $A_{i}$. It follows that,\n\n\\[\n\\mathbb{E}[X_{i}] = n \\cdot (1 - (1 - |A^{r}_{i}|/n)^{t}) \\\\\n\\geq n \\cdot \\left(1 - \\frac{1}{1 + |A^{r}_{i}|t/n}\\right) \\\\\n= \\frac{t}{1 + |A^{r}_{i}|t/n} \\cdot |A^{r}_{i}| \\\\\n> (t/2) \\cdot |A^{r}_{i}| = (t/2) \\cdot n^{1-(i+1)/k}\n\\]\n\nLemma 4.4. $|A_{i}| \\geq (t/4) \\cdot n^{1-(i+1)/k}$ for all $i \\in [k-1]$ with probability at least $1 - 1/(2n^{2})$"
    },
    {
      "type": "text",
      "text": "Proof. Let O_u : V → [n] be the ordering of vertices V by sorting vertices based on their distance to vertex u in G, with ties broken arbitrarily. For example, the j^th-closest vertex to u in G maps to j. We note d(u, p_{i+1}(u)) ≤ d(u, A^r_i - {w}) if at least one vertex in A_{i+1} comes before all the vertices in A^r_i - {w} in this ordering. Suppose that for a vertex v ∈ A_{i+1} we have O_u(v) = j. By Lemma 4.3, since each vertex has an equal probability of being included in the set A^r_i, the probability that all the vertices in A^r_i - {w} come after v, or O_u(y) > O_u(v) for all y ∈ A^r_i - {w}, is (1 - j/n)^{|A^r_i|-1}. Also by Lemma 4.3, the probability that O_u(v) = j is 1/n for every j ∈ [n]. Since the events O_u(v) = j and O_u(v) = m are clearly disjoint when j ≠ m, we have that,\n\nP[d(u, v) ≤ d(u, A^r_i - {w})] = P[⋃_{j=1}^n (O_u(v) = j) ∩ (O_u(y) > j for all y ∈ A^r_i - {w})]\n\n= ∑_{j=1}^{n} (1 - j/n)^{|A^r_i|-1} (1/n)\n\n≥ ∫_{1/n}^1 (1 - x)^{|A^r_i|-1} dx\n\n= (1 - 1/n)^{|A^r_i|} / |A^r_i|\n\n≥ (1 - (|A^r_i| / n)) / |A^r_i| ≥ 1 / (2|A^r_i|)\n\nwhere the last inequality follows from |A^r_i|/n ≤ n^{-2/k} ≤ n^{-1/k} ≤ 1/2. We note that |A^r_i| = n^{1-(i+1)/k} and by Lemma 4.4 we condition on the event that |A_{i+1}| ≥ (t/4) · n^{1-(i+2)/k} for all i ∈ [k-2] with probability at least 1 - 1/(2n^2). Hence, the probability that at least one of the vertices in A_{i+1} comes before A^r_i - {w} in the ordering O_u is at least,\n\nP[d(u, p_{i+1}(u)) ≤ d(u, A^r_i - {w})] ≥ 1 - (1 - 1/(2|A^r_i|))^{|A_{i+1}|}\n\n≥ 1 - (1 - 1/(2|A^r_i|))^{(t/4)·n^{1-(i+2)/k}}\n\n≥ 1 - n^{-7}\n\nwhere the last inequality follows from Proposition E.1. We condition on the event d(u, p_{i+1}(u)) ≤ d(u, A^r_i - {w}) for all u ∈ V, for all levels 1 through k - 2, for all t iterations with probability at least 1 - n·t·k/n^7,\n\nwhere the last inequality follows from |A^r_i|/n ≤ n^{-2/k} ≤ n^{-1/k} ≤ 1/2. We note that |A^r_i| = n^{1-(i+1)/k} and by Lemma 4.4 we condition on the event that |A_{i+1}| ≥ (t/4) · n^{1-(i+2)/k} for all i ∈ [k-2] with probability at least 1 - 1/(2n^2). Hence, the probability that at least one of the vertices in A_{i+1} comes before A^r_i - {w} in the ordering O_u is at least,\n\nP[d(u, p_{i+1}(u)) ≤ d(u, A^r_i - {w})] ≥ 1 - (1 - 1/(2|A^r_i|))^{|A_{i+1}|}\n\n≥ 1 - (1 - 1/(2|A^r_i|))^{(t/4)·n^{1-(i+2)/k}}\n\n≥ 1 - n^{-7}\n\nwhere the last inequality follows from Proposition E.1. We condition on the event d(u, p_{i+1}(u)) ≤ d(u, A^r_i - {w}) for all u ∈ V, for all levels 1 through k - 2, for all t iterations with probability at least 1 - n·t·k/n^7,\n\nLemma 4.5. For all i ∈ [k-2], r ∈ [t], u ∈ V, if w ∈ A^r_i is the closest to u in G, then d(u, p_{i+1}(u)) ≤ d(u, A^r_i - {w}) with probability at least 1 - 1/n^2.\n\nwhere the first inequality follows from Bernoulli's inequality, and the last inequality follows from |A^r_i| · t ≤ n.\n\nFurthermore, by a Chernoff bound (Lemma 2.5 with λ = E[X_i]/2), we have that P[X_i ≤ E[X_i]/2] ≤ e^{-E[X_i]/8}. The expectation of X_i, E[X_i] is minimized when i = k - 1, as we sample the least amount of vertices in A_{k-1}. So, E[X_i] ≥ E[X_{k-1}] ≥ t/2 = 50 · n^{1/k} log n. Hence, we have that\n\nP[X_i ≤ E[X_i]/2] ≤ e^{-E[X_i]/8}\n≤ exp (-(50/8) · n^{1/k} log n)\n= n^{-(50/8)n^{1/k}} ≤ 1/(2n^3)\n\nwhere the first inequality follows from Bernoulli's inequality, and the last inequality follows from |A^r_i| · t ≤ n.\n\nSince the assumption k ≤ ⌊log(n)/log(2)⌋ implies k ≤ n, by a union bound we get that the event |A_i| ≥ (t/4) · n^{1-(i+1)/k} for all 1 ≤ i ≤ k - 1 occurs with probability at least 1 - 1/(2n^2).\n\nFinally, we make the key observation that our sets A_{i+1} are large enough relative to the size of A^r_i such that every vertex in a cluster C^r(w) is closer to the set A_{i+1} than A^r_i - {w} for every i ∈ [k-2], r ∈ [t]."
    },
    {
      "type": "text",
      "text": "by a union bound. Furthermore, $t \\cdot k \\leq \\frac{100}{\\log(2)} \\cdot n^{1/k} \\cdot \\log^2 (n) \\leq n^3$ for all $n$ sufficiently large, where the first inequality holds from $k \\leq \\lfloor\\log (n)/ \\log (2)\\rfloor$. Hence, $t \\cdot k/n^6 \\leq 1/n^3 \\leq 1/(2n^2)$, so the probability of success is bounded below by $1 - 1/(2n^2)$. By a union bound with Lemma 4.4, $d(u, p_{i+1}(u)) \\leq d(u, A_i^r - \\{w\\})$ occurs with probability at least $1 - 1/n^2$.\n\nThe next step in our algorithm is to form a collection $\\mathbf{T}$ of trees, the distances in which will be used to compute the final distance estimates as in the construction from the previous section. In particular, to construct $T_i^r \\in \\mathbf{T}$, we begin by letting $T_i^r = (V, \\emptyset)$. Then, for each center $w \\in A_i^r$, we add the edges of the shortest path tree centered at $w$ and spanning $C^r(w)$ to $T_i^r$. By Lemma 4.2, $T_i^r$ is a forest. To connect the components of the forest into a single spanning tree of $G$, we imagine contracting each cluster into its center and adding the vertices of the minimum spanning tree of the new graph to $T_i^r$.\n\nIn fact, we do not utilize the distances between clusters in each level, so any arbitrary connection of the components such that no cycles are formed is adequate. To give an explicit algorithm for connecting the clusters into a single spanning tree, we give a simple modification of Kruskal's algorithm [Kru56]. In specific, let $E'$ be the set of edges $E(G) - E(T_i^r)$. We (1) pick the edge in $E'$ with the smallest weight, with ties broken arbitrarily, and check if it forms a cycle in $T_i^r$. If it doesn't, we add the edge to $T_i^r$. Then, we remove the edge from $E'$. We (2) repeat step (1) until $T_i^r$ has $n - 1$ edges. By the condition in step (1) and Lemma 4.2, $T_i^r$ is acyclic. Furthermore, $T_i^r$ cannot be disconnected as the graph $G$ is connected and the first edge encountered in $E'$ that connects two disconnected components in $T_i^r$ must be added to $T_i^r$ as it won't form a cycle.\n\nNow we let $\\mathbf{T} = \\cup_i \\cup_r T_i^r$. In this way, we construct exactly one spanning tree for each set $A_i^r$, hence there are $t \\cdot k = 100 \\cdot k n^{1/k} \\log(n)$ total trees in $\\mathbf{T}$. Next, we analyze the maximum stretch of the distance estimates computed in $\\mathbf{T}$, which parallels the analysis in [TZ05]. We begin by showing that the pivot of a vertex is always included in its bunch.\n\nLemma 4.6. For all $i \\in [k-1]$ and $u \\in V$, $p_i(u) \\in B(u)$.\n\nProof. The claim follows by induction on the index $i$. For the base case of $i = k-1$, since $A_k = \\emptyset$, for all $w \\in A_{k-1}$, $d(w, A_k) = \\infty$. Consequently, $d(w, u) < d(w, A_k)$, so $w \\in B(u)$. It follows that $p_{k-1}(u) \\in A_{k-1} \\subseteq B(u)$. Suppose further that $i < k-1$ and $p_{i+1}(u) \\in B(u)$. There are two cases. In the first case, $d(u, A_i) = d(u, A_{i+1})$, and $p_i(u) \\leftarrow p_{i+1}(u) \\in B(u)$ by Line 16. In the second case, $d(u, A_i) = d(u, p_i(u)) < d(u, A_{i+1})$, and hence $p_i(u) \\in B(u)$ by the definition of bunches.\n\nFor a pair of vertices $u, v \\in V$, to compute a distance estimate $\\tilde{d}(u, v)$, we first introduce a placeholder variable $w = u$ and initially set $i = 0$. If $w \\in B(v)$, then the algorithm stops. Otherwise, we let $i \\leftarrow i + 1$, swap $u$ and $v$, and let $w \\leftarrow p_i(u) \\in A_i$. We repeat this process of checking if $w \\in B(v)$ and swapping until the algorithm stops. We note that the algorithm is guaranteed to stop as $A_{k-1} \\subseteq B(v)$ for every vertex."
    },
    {
      "type": "image_url",
      "image_url": {
        "url": "data:image/jpeg;base64,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"
      }
    },
    {
      "type": "text",
      "text": "v ∈ V, as the cluster constructed for each vertex in A_{k-1} in Line 3 of Algorithm 2 is simply the entire vertex set. Once the swapping algorithm stops, we let d(u, v) = d(w, u) + d(w, v).\n\nIt remains to show that the swapping procedure outlined above indeed releases an estimate with stretch at most (2k − 1), which we will prove next.\n\nProof. Let Δ = d_G(u, v). Initially, we set w = u, hence d(w, u) = 0. We will show that each iteration of the swapping procedure increases d(w, u) by at most Δ. Let u_i, v_i, and w_i be the values of the variables u, v, and w respectively in iteration i ∈ [k − 1] of the algorithm. If the algorithm does not terminate at iteration i − 1, then w_{i-1} ∉ B(v_{i-1}), so d(w_{i-1}, v_{i-1}) ≥ d(A_i, v_{i-1}) = d(p_i(v_{i-1}), v_{i-1}). However, since v_{i-1} = u_i and w_i = p_i(u_i), we have that,\n\nd(w_i, u_i) = d(p_i(u_i), u_i) = d(p_i(v_{i-1}), v_{i-1}) ≤ d(w_{i-1}, v_{i-1}) ≤ d(w_{i-1}, u_{i-1}) + Δ\n\nSince A_{k-1} ⊆ B(v), there are at most k−1 iterations in the algorithm, hence d(w, u) ≤ (k−1)Δ. Furthermore, d(w, v) ≤ d(w, u) + d(u, v) ≤ (k − 1)Δ + Δ = kΔ by the triangle inequality. It follows that d(u, v) = d(w, u) + d(w, v) ≤ (2k − 1)Δ.\n\nWe can now apply Corollary 4.1 to the set T of trees as in the previous section.\n\nTheorem 4.3. For γ ∈ (0, 0.5], ε ∈ (0, 1], and k ∈ {2, ..., ⌊log(n)/log(2)⌋}, there is an ε-DP algorithm for computing all-pairs shortest distances that is (2k − 1, O(k · n^{1/k} · log^{2.5}(n) · log(k) · log(1/γ)/ε))-accurate with probability 1 − γ − 1/n^2.\n\nProof. For each T ∈ T and u, v ∈ V, we run the ε/(t·k)-DP algorithm given by Corollary 4.1 to release the private distance estimates 𝑑̃_T(u, v) and let 𝑑̃(u, v) ← min_{T∈T} 𝑑̃_T(u, v). By basic composition (Lemma 2.1), releasing all the private estimates is ε-DP. Moreover, for each 𝑑̃_T(u, v), the result of Corollary 4.1 guarantees that, with probability 1−γ by a union bound over all t·k trees,\n\nmax_{u,v∈V} |d_T(u, v) − 𝑑̃_T(u, v)| ≤ O(k · n^{1/k} · log^{1.5}(n) · log(n · t · k/γ)/ε)\n= O(k · n^{1/k} · log^{2.5}(n) · log(k) · log(1/γ)/ε)        (3)\n\nby Proposition E.2. Moreover, we note that for our distance estimate d(u, v) = d(w, u) + d(w, v), w ∈ A^m_l for some m ∈ [t] and l ∈ [k − 1]. Furthermore, w ∈ B(v) as it is a condition for stopping, and w ∈ B(u) by Lemma 4.6. w ∈ B(u) implies d(w, u) < d(u, p_{i+1}(u)) ≤ d(u, A^r_i − {w}) with probability 1 − 1/n^2 by Lemma 4.5, and consequently u ∈ C^m(w). By equivalent logic, v ∈ C^m(w). It follows that, with probability 1 − 1/n^2, for any pair of vertices u, v ∈ V there is some tree T* ∈ T such that d(u, v) = d(w, u) + d(w, v) = d_{T*}(w, u) + d_{T*}(w, v). Hence, by Lemma 4.7,\n\nmin_{T∈T} d_T(u, v) ≤ (2k − 1) · d_G(u, v)        (4)\n\nBy a union bound, the upper bounds (3) and (4) hold with probability 1 − γ − 1/n^2, and ensure that,\n\nd_G(u, v) − O(k · n^{1/k} · log^{2.5}(n) · log(k) · log(1/γ)/ε) ≤ 𝑑̃(u, v)\n≤ (2k − 1) · d_G(u, v) + O(k · n^{1/k} · log^{2.5}(n) · log(k) · log(1/γ)/ε)\n\nConsequently, the algorithm is (2k −1, O(k · n^{1/k} · log^{2.5}(n) · log(k) · log(1/γ)/ε))-accurate, as claimed.\n\nThe proof of the following theorem is analogous to the proof of Theorem 4.3, and hence is deferred to Appendix D.\n\nTheorem 4.4. For γ ∈ (0, 0.5], ε, δ ∈ (0, 1], and k ∈ {2, ..., ⌊log(n)/log(2)⌋}, there is an (ε, δ)-DP algorithm for computing all-pairs shortest distances that is (2k − 1, O(√k · n^{1/(2k)} · log^{2.5}(n) · √log(2/δ) · log(k) · log(1/γ)/ε))-accurate with probability 1 − γ − 1/n^2.\n\nFinally, we give a short justification as to why our assumption that k ≤ ⌊log(n)/log(2)⌋ is reasonable. When k = ⌊log(n)/log(2)⌋, both multiplicative and additive errors become O(polylog(n)). As such, further increasing the value of k would only increase the multiplicative error."
    },
    {
      "type": "text",
      "text": "In this work, we give an algorithm to release all-pairs shortest distances for general graphs with Õ(n^{1/3}/ε) additive error in the ε-DP setting and Õ(n^{1/4}/ε) additive error in the (ε,δ)-DP setting, which is optimal up to a polylogarithmic factor based on the lower bound of Ω(n^{1/4}/√log n) proven by [BDG+24]. In the case with the added assumption that the edge weights are in (0, M] for some M ∈ ℝ^+, [CGK+23] showed that there is a constant c > 0 such that no (ε,δ)-DP algorithm for APSD can be o(n^c)-accurate, even when M = O(1). That is, one natural open question is whether an algorithm with error O(n^{1/4-Ω(1)}) is possible in the bounded edge weights setting.\n\nFurthermore, we give algorithms on general graphs that have additive error whose polynomial dependence on n beats the known lower bound for purely additive algorithms if one allows a multiplicative approximation. The question remains open that whether an algorithm with an O(1) multiplicative approximation and O(polylog(n)) additive approximation is possible.\n\nThis material is based upon work supported by the National Science Foundation Grant CNS-2349369. This work was completed during the UNCG GraLNA 2024 REU, where Jesse Campbell was working under the mentorship of Chunjiang Zhu."
    },
    {
      "type": "text",
      "text": "[CL01] B. Chazelle and A. Lvov. A trace bound for the hereditary discrepancy. Discrete & Computational Geometry, 26(2):221–231, 2001.\n\n[CL06] Fan Chung and Linyuan Lu. Concentration inequalities and martingale inequalities: a survey. Internet Mathematics, 3(1):79–127, 2006.\n\n[CSC+24] Bin Cai, Weihong Sheng, Jiajun Chen, Chunqiang Hu, and Jiguo Yu. Shortest paths publishing with differential privacy. IEEE Transactions on Sustainable Computing, 9(2):209–221, 2024.\n\n[CSS11] Hubert Chan, Elaine Shi, and Dawn Song. Private and continual release of statistics. ACM Trans. Inf. Syst. Secur., 14(3), 2011.\n\n[DGUW23] Chengyuan Deng, Jie Gao, Jalaj Upadhyay, and Chen Wang. Differentially private range query on shortest paths. In Pat Morin and Subhash Suri, editors, Algorithms and Data Structures - 18th International Symposium, WADS 2023, Proceedings, pages 340–370, Germany, 2023. Springer Science and Business Media Deutschland GmbH.\n\n[DKY17] Bolin Ding, Janardhan Kulkarni, and Sergey Yekhanin. Collecting telemetry data privately. In I. Guyon, U. Von Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett, editors, Advances in Neural Information Processing Systems, volume 30. Curran Associates, Inc., 2017.\n\n[DL09] Cynthia Dwork and Jing Lei. Differential privacy and robust statistics. In Proceedings of the Forty-First Annual ACM Symposium on Theory of Computing, STOC '09, page 371–380, New York, NY, USA, 2009. Association for Computing Machinery.\n\n[DMNS06] Cynthia Dwork, Frank McSherry, Kobbi Nissim, and Adam Smith. Calibrating noise to sensitivity in private data analysis. In Shai Halevi and Tal Rabin, editors, Theory of Cryptography, pages 265–284, Berlin, Heidelberg, 2006. Springer Berlin Heidelberg.\n\n[DR14] Cynthia Dwork and Aaron Roth. The algorithmic foundations of differential privacy. Foundations and Trends in Theoretical Computer Science, 9(3–4):211–407, 2014.\n\n[ELRS23] Talya Eden, Quanquan C. Liu, Sofya Raskhodnikova, and Adam Smith. Triangle counting with local edge differential privacy. arXiv preprint, arXiv:2305.02263, 2023.\n\n[EMK23] Javad B. Ebrahimi, Alireza Tofighi Mohammadi, and Fatemeh Kermani. Differentially private all-pairs shortest distances for low tree-width graphs. In 2023 International Symposium on Networks, Computers and Communications (ISNCC), pages 1–6, 2023.\n\n[FL22] Chenglin Fan and Ping Li. Distances release with differential privacy in tree and grid graph. In 2022 IEEE International Symposium on Information Theory (ISIT), pages 2190–2195, 2022.\n\n[FLL22] Chenglin Fan, Ping Li, and Xiaoyun Li. Breaking the linear error barrier in differentially private graph distance release. NeurIPS, 2022.\n\n[FMM19] Andrew David Foote, Ashwin Machanavajjhala, and Kevin McKinney. Releasing earnings distributions using differential privacy: Disclosure avoidance system for post-secondary employment outcomes (pseo). Journal of Privacy and Confidentiality, 9(2), 2019.\n\n[GAP18] Simson L. Garfinkel, John M. Abowd, and Sarah Powazek. Issues encountered deploying differential privacy. In Proceedings of the 2018 Workshop on Privacy in the Electronic Society, WPES'18, page 133–137, New York, NY, USA, 2018. Association for Computing Machinery.\n\n[HCYH24] Calvin Hawkins, Bo Chen, Kasra Yazdani, and Matthew Hale. Node and edge differential privacy for graph laplacian spectra: Mechanisms and scaling laws. IEEE Transactions on Network Science and Engineering, 11(2):1690–1701, 2024."
    },
    {
      "type": "text",
      "text": "The proofs presented are slightly modified from [Sea16] and are given for completeness. In particular, in the proof of Lemma 3.2 instead of showing that, with probability 1 − γ, any single released distance is bounded above by some term, we show that with probability 1 − γ, all the released distances are bounded above by some term. We do this by letting the probability of failure for releasing any single distance to be γ/n such that, by a union bound, the total failure probability over all n released distances is γ. This gives a term log (n/γ) in the final bound instead of log (1/γ) as in the original proof. We note that this slightly changes our proof of Corollary 4.1, however it does not affect the final result.\n\nLemma 3.2. Let T_z = (V, E, w) be a tree with root vertex z ∈ V, ε ∈ (0, 1], and γ ∈ (0, 0.5]. Then there is an ε-DP algorithm for releasing the distance between z and every u ∈ V that is O(log^1.5(n) · log(n/γ)/ε)-accurate with probability 1 − γ.\n\nProof. Let T_z be the tree rooted at vertex z ∈ V. The algorithm works by splitting the tree into subtrees, each with fewer than n/2 vertices, computing distances between the root and the roots of the subtrees, and then applying the algorithm recursively on each subtree.\n\nIt is a well-known result that every tree has either one or two vertices known as centroids such that their removal disconnects the tree into subtrees, each with fewer than n/2 vertices (see, for example, [Wan15]). If T_z has a single centroid, we let z* be that vertex. If T_z has two centroids, we let z* be the centroid that is closer to the root node z. By choosing it in this way, we guarantee that z* is the unique vertex such that the subtree rooted at z* has more than n/2 vertices, but the subtree rooted at each of z*'s children has at most"
    },
    {
      "type": "text",
      "text": "n/2 vertices. Let z₁, ..., zₜ be the children of z* and Tᵢ = (Vᵢ, Eᵢ), i ∈ {1, ..., t}, their corresponding subtrees. Additionally, we define T₀ to be the subtree rooted at z with vertex set V₀ = V − {V₁, ..., Vₜ}.\n\nNext, we release the distances between z and z*, as well as between z* and each of its children by adding Laplace noise from the distribution Lap(log(n)/ε). In particular, we note that since each tree is disjoint by construction, the function which releases these distances has sensitivity 1. Hence, by Lemma 2.3, releasing each subtree is (ε/ log(n))-DP. Then, we recursively call this algorithm for each subtree until each subtree consists only of a single vertex.\n\nSince each tree has at most n/2 vertices, the maximum recursion depth is bounded by log(n). Hence, by basic composition (Lemma 2.1), since the released distances in our algorithm are a composition of log(n), (ε/ log(n))-DP mechanisms, the total algorithm is ε-DP.\n\nIt remains to be shown that the error in each released distance is bounded above by O(polylog(n)). We note that for every u ∈ V, the distance d(z, u) is the composition of released distances from root nodes to centroids, and from centroids to their children. By bounding the number of released distances in the composition, we can bound the total error incurred from each noisy random variable.\n\nWe will prove by induction on the number of vertices that the number of released distances used to calculate d(z, u) is bounded above by 2 log(n). Firstly, the base case of n = 1 is vacuously true. Suppose n > 1. In the first iteration of the algorithm, the vertex sets V₀, V₁, ..., Vₜ are a partition of V. Hence, u ∈ Vᵢ for some i ∈ [t]. By the induction hypothesis, we can release the distance from zᵢ to u by the composition of at most 2 log(n/2) = 2 log(n) − 2 noisy distances. Then, we have that d(z, zᵢ) = d(z, z*) + d(z*, zᵢ), giving a total of 2 log(n) noisy distances.\n\nIt follows that the error in each released distance is the concatenation of 2 log(n) random variables distributed according to Lap(log(n)/ε). By Lemma 2.4, with probability at most γ/n, we have that the error exceeds O(log¹·⁵(n)·log(n/γ)/ε). Hence, by a union bound, with probability at least 1−γ, the error for any distance from z to a vertex u ∈ V is bounded above by O(log¹·⁵(n)·log(n/γ)/ε), as desired.\n\n**Corollary 4.1.** Let T = (V, E, w) be a tree with ε ∈ (0, 1] and γ ∈ (0, 0.5]. Then there is an ε-DP algorithm for releasing all-pairs distances on T that is O(log¹·⁵(n)·log(n/γ)/ε)-accurate with probability 1 − γ.\n\n**Proof.** Choose a vertex z ∈ V arbitrarily as a root vertex of T, and call the rooted tree T_z. Then, using Lemma 3.2, we can privately release the distance from z to every other vertex in T_z. We will show that these distances suffice to compute the distance for any pair x, y ∈ V of vertices in V.\n\nLet vₓ,ᵧ ∈ V be the lowest common ancestor of x and y in the rooted tree T_z. Then, d_T(x, y) = d_T(x, vₓ,ᵧ) + d_T(vₓ,ᵧ, y) = d_{T_z}(z, x) + d_{T_z}(z, y) − 2d_{T_z}(z, vₓ,ᵧ). By the result in Lemma 3.2, we condition on the event that for all w ∈ V, d(z, w) is O(log¹·⁵(n)·log(n/γ)/ε)-accurate with probability 1 − γ. Since our distance estimate is the sum of four distances from z, the total error is at most four times this, which is still O(log¹·⁵(n)·log(n/γ)/ε).\n\n## B Proof of Theorem 3.2\n\n**Theorem 3.2.** For γ ∈ (0, 0.5] and ε, δ ∈ (0, 1], there is an (ε, δ)-DP algorithm for computing all-pairs shortest distances that is O(n^{1/4}·log²(n)·√log(2/δ)·log(1/γ)/ε)-accurate with probability 1 − γ − 1/n².\n\n**Proof.** The algorithm is the same as Algorithm 1, except we run the ε/(4√2s log(2/δ))-DP algorithm from Lemma 3.2 to release the shortest path distances in each tree. Namely, in Lines 7 and 9 we sample the Laplacian noise from Lap(4√2|S| log(2/δ)·log(n)/ε). By advanced composition (Lemma 2.2), running the s, ε/(4√2s log(2/δ))-DP mechanisms is (ε/2, δ)-DP. By basic composition (Lemma 2.1), running the (ε/2, δ)-DP mechanism and the ε/2-DP input perturbation algorithm is (ε, δ)-DP.\n\nWe note that the upper bound for the additive error from distance estimates computed via the input perturbation algorithm is the same as in Theorem 3.1. Furthermore, by Lemma 3.2, with probability 1 − γ/2,\n\n\\[\n\\max_{z∈S, u∈V} |d_G(z, u) - \\tilde{d}(z, u)| \\leq O(\\sqrt{s}· \\log^{1.5}(n)· \\sqrt{\\log(2/δ)}· \\log(2sn/γ)/ε)\n\\]\n(5)"
    },
    {
      "type": "text",
      "text": "We again condition on the event (*) and the bounds (5) and (2) with probability $1 - \\gamma - 1/n^2$. Moreover, in Line 1 we choose $s = \\sqrt{n}/(\\log(n) \\cdot \\sqrt{\\log(2/\\delta)})$, and hence the upper bounds (5) and (2) ensure,\n\\[\n\\max_{u,v \\in V} |d_G(u, v) - d(u, v)| \\leq O\\left(n^{1/4} \\cdot \\log^2(n) \\cdot \\sqrt{\\log(2/\\delta)} \\cdot \\log(1/\\gamma)/\\varepsilon\\right)\n\\]\nby Proposition E.2.\n\nTheorem 4.2. For any $\\gamma \\in (0, 0.5]$, $k \\in \\mathbb{Z}^+$ and $\\varepsilon, \\delta \\in (0, 1]$, there is an $(\\varepsilon, \\delta)$-DP algorithm to release all-pairs shortest distances that is $(O(k \\log \\log n), O(\\sqrt{k} \\cdot n^{1/(2k)} \\cdot \\log^{2.5}(n) \\cdot \\log(k) \\cdot \\sqrt{\\log(2/\\delta)} \\cdot \\log(1/\\gamma)/\\varepsilon))$-accurate with probability $1 - \\gamma$.\n\nProof. The proof is identical to the proof of Theorem 4.1, except we run the $\\varepsilon/(2\\sqrt{2}(k n^{1/k}) \\log(2/\\delta))$-DP algorithm from Corollary 4.1 to release APSD for each tree $\\mathcal{T} \\in \\mathbb{T}$. By advanced composition (Lemma 2.2), releasing all the distances is $(\\varepsilon, \\delta)$-DP. Moreover, the result of Corollary 4.1 ensures that with probability $1-\\gamma$,\n\\[\n\\max_{u,v \\in V} |d_{\\mathcal{T}}(u, v) - \\tilde{d}_{\\mathcal{T}}(u, v)| \\leq O(\\sqrt{k} \\cdot n^{1/(2k)} \\cdot \\log^{2.5}(n) \\cdot \\log(k) \\cdot \\sqrt{\\log(2/\\delta)} \\cdot \\log(1/\\gamma)/\\varepsilon)\n\\]\nby Proposition E.2. By letting $\\tilde{d}(u, v) \\leftarrow \\min_{\\mathcal{T} \\in \\mathbb{T}} \\tilde{d}_{\\mathcal{T}}(u, v)$, the result in Lemma 4.1 guarantees the total algorithm is $(O(k \\log \\log n), O(\\sqrt{k} \\cdot n^{1/(2k)} \\cdot \\log^{2.5}(n) \\cdot \\log(k) \\cdot \\sqrt{\\log(2/\\delta)} \\cdot \\log(1/\\gamma)/\\varepsilon))$-accurate, as claimed.\n\nTheorem 4.4. For $\\gamma \\in (0, 0.5]$, $\\varepsilon, \\delta \\in (0, 1]$, and $k \\in \\{2, ...,\\lfloor \\log(n)/\\log(2) \\rfloor \\}$, there is an $(\\varepsilon, \\delta)$-DP algorithm for computing all-pairs shortest distances that is $(2k-1, O(\\sqrt{k} \\cdot n^{1/(2k)} \\cdot \\log^{2.5}(n) \\cdot \\sqrt{\\log(2/\\delta)} \\cdot \\log(k) \\cdot \\log(1/\\gamma)/\\varepsilon))$-accurate with probability $1-\\gamma-1/n^2$.\n\nProof. The proof is the same as Theorem 4.3, except we run the $\\varepsilon/(2\\sqrt{2}(t\\cdot k) \\cdot \\log(2/\\delta))$-DP algorithm given by Corollary 4.1 to release private APSD $\\tilde{d}_{\\mathcal{T}}(u, v)$ for each $\\mathcal{T} \\in \\mathbb{T}$. By advanced composition (Lemma 2.2), releasing the distances is $(\\varepsilon, \\delta)$-DP. Moreover, by a union bound over all $t \\cdot k$ trees, with probability $1-\\gamma$,\n\\[\n\\max_{u,v \\in V} |d_{\\mathcal{T}}(u, v) - \\tilde{d}_{\\mathcal{T}}(u, v)| \\leq O(\\sqrt{k} \\cdot n^{1/(2k)} \\cdot \\log^{2.5}(n) \\cdot \\sqrt{\\log(2/\\delta)} \\cdot \\log(k) \\cdot \\log(1/\\gamma)/\\varepsilon)\n\\]\nby Proposition E.2. The stretch analysis is the same as in Theorem E.2. Consequently, with probability $1-\\gamma-1/n^2$, the algorithm is $(2k-1, O(\\sqrt{k} \\cdot n^{1/(2k)} \\cdot \\log^{2.5}(n) \\cdot \\sqrt{\\log(2/\\delta)} \\cdot \\log(k) \\cdot \\log(1/\\gamma)/\\varepsilon))$-accurate.\n\nWe will make use of the following result several times, and so we prove it here for convenience.\n\nProposition E.1. For any $x \\in (0, 1)$, $n > 0$ and $m \\in \\mathbb{Z}^+$, we have that,\n\\[\n(1-x)^{mx^{-1} \\log(n)} \\leq n^{-m}\n\\]\n\nProof. First, note that $(1-x)^{mx^{-1} \\log(n)} = n^{mx^{-1} \\log(1-x)}$. Hence, it suffices to show that $mx^{-1} \\log(1-x) \\leq -m$. To see this, we let $f(x) = mx^{-1} \\log(1-x)$ and note that $\\lim_{x\\to 0^+} f(x) = -m$, and $f'(x)<0$ for all $x \\in (0, 1)$.\n\nFinally, we state some elementary results regarding big-$O$ notation which we will use several times throughout this paper in order to simplify the arguments of our asymptotic upper-bounds."
    },
    {
      "type": "text",
      "text": "**Proposition E.2.** Let $\\alpha \\geq 2$, $\\gamma \\in (0, 0.5]$, and $\\lambda > 0$, then\n\n1. $\\log(\\alpha^{1+\\lambda}/\\gamma) = O(\\log(\\alpha/\\gamma))$, and,\n2. $\\log(\\alpha/\\gamma) = O(\\log(\\alpha) \\log(1/\\gamma))$.\n\n**Proof of 1.** $\\log(\\alpha^{1+\\lambda}/\\gamma) = \\log((\\alpha/\\gamma^{1/(1+\\lambda)})^{1+\\lambda}) = (1+\\lambda) \\cdot \\log(\\alpha/\\gamma^{1/(1+\\lambda)}) \\leq (1+\\lambda) \\cdot \\log(\\alpha/\\gamma) = O(\\log(\\alpha/\\gamma))$.\n\n**Proof of 2.** Suppose the base of our logarithm is $b = \\{2, e\\}$. Then\n\n$\\log(\\alpha/\\gamma) = \\log(\\alpha) + \\log(1/\\gamma) = O(\\max\\{\\log(\\alpha), \\log(1/\\gamma)\\}) = O(\\log(\\alpha) \\log(1/\\gamma))$\n\nas $\\alpha, 1/\\gamma \\geq 2$.\n\n$\\Box$"
    }
  ],
  "images": [
    "images/page_13_picture_1.jpg"
  ],
  "pdf": "2407.06913v2_err1.pdf"
}